1806.05421v5 [stat ML] 12 Apr2019

arXiv

Published as a conference paper at ICLR 2019

 

SELFLESS SEQUENTIAL LEARNING

Rahaf Aljundi Marcus Rohrbach
KU Leuven Facebook AI Research
ESAT-PSI, Belgium mrf@fb.com

rahaf.aljundi@gmail.com

Tinne Tuytelaars

KU Leuven

ESAT-PSI, Belgium
tinne.tuytelaars@esat.kuleuven.be

ABSTRACT

Sequential learning, also called lifelong learning, studies the problem of learning
tasks in a sequence with access restricted to only the data of the current task. In
this paper we look at a scenario with fixed model capacity, and postulate that the
learning process should not be selfish, i.e. it should account for future tasks to be
added and thus leave enough capacity for them. To achieve Selfless Sequential
Learning we study different regularization strategies and activation functions. We
find that imposing sparsity at the level of the representation (i.e. neuron activations)
is more beneficial for sequential learning than encouraging parameter sparsity.

In particular, we propose a novel regularizer, that encourages representation spar-
sity by means of neural inhibition. It results in few active neurons which in turn
leaves more free neurons to be utilized by upcoming tasks. As neural inhibition
over an entire layer can be too drastic, especially for complex tasks requiring strong
representations, our regularizer only inhibits other neurons in a local neighbour-
hood, inspired by lateral inhibition processes in the brain. We combine our novel
regularizer with state-of-the-art lifelong learning methods that penalize changes
to important previously learned parts of the network. We show that our new reg-
ularizer leads to increased sparsity which translates in consistent performance
improvement on diverse dataset].

1 INTRODUCTION

Sequential learning, also referred to as continual, incremental, or lifelong learning (LLL), studies the
problem of learning a sequence of tasks, one at a time, without access to the training data of previous
or future tasks. When learning a new task, a key challenge in this context is how to avoid catastrophic
interference with the tasks learned previously (French| |T999} [Li & Hoiem| |2016). Some methods
exploit an additional episodic memory to store a small amount of previous tasks data to regularize
future task learning (e.g. (2017)). Others store previous tasks models and at test time,
select one model or merge the models (Rusu et al. 2016} Aljundi et al.| 2016} Lee et al] 2017). In
contrast, in this work we are interested in the challenging situation of learning a sequence of tasks
without access to any previous or future task data and restricted to a fixed model capacity, as also
studied in|Kirkpatrick et al.|(2016);|Aljundi et al.|(2017);|Fernando et al.|(2017);|Mallya & Lazebnik
(2017); . This scenario not only has many practical benefits, including privacy an
scalability, but also resembles more closely how the mammalian brain learns tasks over time.

 

 
    

 

The mammalian brain is composed of billions of neurons. Yet at any given time, information is
represented by only a few active neurons resulting in a sparsity of 90-95% (Lennie} [2003). In
neural biology, lateral inhibition describes the process where an activated neuron reduces the activity
of its weaker neighbors. This creates a powerful decorrelated and com epresentation with
minimum interference between different input patterns in the brain ( ). This is in stark

   
 

 

'The code is available at https: //github.com/rahafaljundi/Selfles

Sequential-Learning

 
Published as a conference paper at ICLR 2019

 

11

Dec 2POOOO : OC “
(a) Parameter sparsity (b) Represantation sparsity

 

Figure 1: The difference between parameter sparsity (a) and representation sparsity (b) in a simple two tasks
case. First layer indicates input patterns. Learning the first task utilizes parts indicated in red. Task 2 has
different input patterns and uses parts shown in green. Orange indicates changed neurons activations as a result
of the second task. In (a), when an example from the first task is encountered again, the activations of the first
layer will not be affected by the changes, however, the second and later layer activations are changed. Such
interference is largely reduced when imposing sparsity on the representation (b).

 

contrast with artificial neural networks, which typically learn dense representations that are highly
entangled Such an entangled representation is quite sensitive to changes in
the input patterns, in that it responds differently to input patterns with only small variations nc
suggests that an overlapped representation plays a crucial role in Pata forgetting and
reducing this overlap would result in a reduced interference. [Cogswell et al.] 1.| (2015) show that when
the amount of overfitting in a neural network is reduced, the - Rosswet ata corre cite is also reduced.
As such, learning a disentangled representation is more powerful and less vulnerable to catastrophic
interference. However, if the learned disentangled representation at a given task is not sparse, only
little capacity is left for learning new tasks. This would in turn result in either an underfitting to the
new tasks or again a forgetting of previous tasks. In contrast, a sparse and decorrelated representation
would lead to a powerful representation and at the same time enough free neurons that can be changed
without interference with the neural activations learned for the previous tasks.

   
 

In general, sparsity in neural networks can be thought of either in terms of the network parameters
or in terms of the representation (i.e., the activations). In this paper we postulate, and confirm
experimentally, that a sparse and decorrelated representation is preferable over parameter sparsity
in a sequential learning scenario. There are two arguments for this: first, a sparse representation is
less sensitive to new and different patterns (such as data from new tasks) and second, the training
procedure of the new tasks can use the free neurons leading to less interference with the previous
tasks, hence reducing forgetting. In contrast, when the effective parameters are spread among
different neurons, changing the ineffective ones would change the function of their corresponding
neurons and hence interfere with previous tasks (see also Figure}1). Based on these observations,
we propose a new regularizer that exhibits a behavior similar to the lateral inhibition in biological
neurons. The main idea of our regularizer is to penalize neurons that are active at the same time.
This leads to more sparsity and a decorrelated representation. However, complex tasks may actually
require multiple active neurons in a layer at the same time to learn a strong representation. Therefore,
our regularizer, Sparse coding through Local Neural Inhibition and Discounting (SLNID), only
penalizes neurons locally. Furthermore, we don’t want inhibition to affect previously learned tasks,
even if later tasks use neurons from earlier tasks. An important component of SLNID is thus
to discount inhibition from/to neurons which have high neuron importance — a new concept that

we introduce a analogy to parameter importance (Kirkpatrick et al. 2016} |Zenke et al.|

Aljundi et al.}/2017). When combined with a state-of-the-art important parameters preservation

method ( Shae et al. 7\|Kirkpatrick et al.|[2016), our proposed regularizer leads to sparse and
decorrelated representations which improves the lifelong learning performance.

 

  

   

Our contribution is threefold. First, we direct attention to Selfless Sequential Learning and study
a diverse set of representation based regularizers, parameter based regularizers, as well as sparsity
inducing activation functions to this end. These have not been studied extensively in the lifelong
learning literature before. Second, we propose a novel regularizer, SLNID, which is inspired by
lateral inhibition in the brain. Third, we show that our proposed regularizer consistently outperforms
alternatives on three diverse datasets (Permuted MNIST, CIFAR, Tiny Imagenet) and we compare to
and outperform state-of-the-art LLL approaches on an 8-task object classification challenge. SLNID
can be applied to different regularization based LLL approaches, and we show experiments with

MAS (Aljundi et al. and EWC (Kirkpatrick et al.||2016).

In the following, we first discuss related LLL approaches and different regularization criteria from a
LLL perspective (Section|2). We proceed by introducing Selfless Sequential Learning and detailing
our novel regularizer (Section p. Section[4|describes our experimental evaluation, while Section5]
concludes the paper.
Published as a conference paper at ICLR 2019

 

2 RELATED WORK

The goal in lifelong learning is to learn a sequence of tasks without catastrophic forgetting of previ-
ously learned ones (iia &: Mitchell 5). One can identify different approaches to introducing
lifelong learning in neural networks. Here, we focus on learning a sequence of tasks using a fixed
model capacity, i.e. with a fixed architecture and fixed number of parameters. Under this setting,
methods either follow a pseudo rehearsal approach, i.e. using the new task data to approximate the

performance of the previous task (Li & Hoiem\|2 7), or aim at identifying the

important parameters used by the current set of t: ind penalizing c 's to those parameters by
new tasks (Kirkpatrick etal 2
2018). To identify the important parameters for a given task, Elastic Weight Consolida-
tion (Kirkpatrick et al.|[2016) uses an approximation of the Fisher information matrix computed after
training a given task. (2018) suggest a network reparameterization to obtain a better diagonal
approximation of the Fisher Information matrix of the network parameters. Path Integral
7) estimates the importance of the network parameters while learning a given task by
accumulating the contribution of each parameter to the change in the loss.
suggest a KL-divergence based generalization of Elastic Weight Consolidation and Path Integral.
Memory Aware Synapses (Aljundi et al. |2017) estimates the importance of the parameters in an
online manner without supervision by measuring the sensitivity of the learned function to small
perturbations on the parameters. This method is less sensitive to the data distribution shift, and a
local version proposed by the authors resembles applying Hebb rule (Hebb][2002) to consolidate the
important parameters, making it more biologically plausible.

 
  
  

  
      

        
   

   

 

 

 

A common drawback of all the above methods is that learning a task could utilize a good portion of
the network capacity, leaving few "free" neurons to be adapted by the new task. This in turn leads to
inferior performance on the newly learned tasks or forgetting the previously learned ones, as we will
show in the experiments. Hence, we study the role of sparsity and representation decorrelation in
sequential learning. This aspect has not received much attention in the literature yet. Very recently,
[2018) proposed to overcome catastrophic forgetting through learned hard attention
masks for each task with L1 regularization imposed on the accumulated hard attention masks. This
comes closer to our approach although we study and propose a regularization scheme on the learned
representation.

The concept of reducing the representation overlap has been suggested before in early attempts
towards overcoming catastrophic forgetting in neural networks (French||1999). This has led to several

methods with the goal of orthogonalizing the activations (Frenchj [1992}|1994} [Kruschke| [T992}

1993} |Sloman & Rumelhart . However, these approaches are mainly designed for specific
architectures and activation functions, which makes it hard to integrate them in recent neural network

structures.

 

The sparsification of neural networks has mostly been studied for compression. SVD decomposition
can be applied to reduce the number of effective parameters (Xue et al.| . However, there is
no guarantee that the training procedure converges to a low rank weight matrix. Other works iterate
between pruning and retraining of a neural network as a post processing step 01

el 6 {2017} 2017). While compressing a neural network by
removing parameters leads to a sparser neural network, this does not necessarily lead to a sparser
representation. Indeed, a weight vector can be highly sparse but spread among the different neurons.
This reduces the effective size of a neural network, from a compression point of view, but it would
not be beneficial for later tasks as most of the neurons are already occupied by the current set of tasks.
In our experiments, we show the difference between using a sparse penalty on the representation
versus applying it to the weights.

   
      

3 SELFLESS SEQUENTIAL LEARNING

One of the main challenges in single model sequential learning is to have capacity to learn new
tasks and at the same time avoid catastrophic forgetting of previous tasks as a result of learning new
tasks. In order to prevent catastrophic forgetting, importance weight based methods such as EWC

(Kirkpatrick et al.) or MAS introduce an importance weight ; for each
(Kirkpatrick et al} 2076) i 2017) P ght

parameter 6), in the network. While these methods differ in how to estimate the important parameters,
Published as a conference paper at ICLR 2019

 

all of them penalize changes to pent parameters when learning a new task T), using Lz penalty:

Ty: min >> Ls Lymn; f(%m;0")) + 0S) Oe (OR = OR")? (1)
k

m=1

where 9”~1 = {6?~'} are the optimal parameters learned so far, i.e. before the current task. {7m}
is the set of M training inputs, with { f(2m,0”)} and {ym } the corresponding predicted and desired
outputs, respectively. Aq is a trade-off parameter between the new task objective £ and the changes
on the important parameters, i.e. the amount of forgetting.

In this work we introduce an additional regularizer Rss, which encourages sparsity in the activations
A, = {hi} for each hi L

1
Ti: min >> e Lym; f (@m,8")) + ro DM (67 — 02-1)? + Asst >> Resi (Hi) (2)
m=1 7
Assi and Ae are trade-off parameters that control ig contribution of each term. When training the
first task (rn = 1), Q;, = 0.

3.1 SPARSE CODING THROUGH NEURAL INHIBITION (SNI)

Now we describe how we obtain a sparse and decorrelated representation. In the literature sparsity has
been proposed by |Glorot et al] ) to be combined with the rectifier activation function (ReLU) to
control unbounded activations and to increase sparsity. They minimize the L; norm of the activations
(since minimizing the Lo norm is an NP hard problem). However, L; norm imposes an equal penalty
on all the active neurons leading to small activation magnitude across the network.

Learning a decorrelated representation has been explored before with the goal of reducing overfitting.
This is usually done by minimizing the Frobenius norm of the covariance matrix corrected by the
diagonal, as in|Cogswell et al.|(2015) or[Xiong et al-|(2016). Such a penalty results in a decorrelated
representation but with activations that are mostly close to a non zero mean value. We merge the two
objectives of sparse and decorrelated representation resulting in the following objective:

Rsy1(Hi) = abn. iFj (3)
ij m

where we consider a hidden layer / with activations H; = {h?"} for a set of inputs X = {x,,,} and
i,j €1,..,.N running over all N neurons in the hidden layer. This formula differs from minimizing
the Frobenius norm of the covariance matrix in two simple yet important aspects:
(1) In the case of a ReLU activation function, used in most modern architectures, a neuron is active if
its output is larger than zero, and zero otherwise. By assuming a close to zero mean of the activations,
bi, ~ OVi € 1,..,.N, we minimize the correlation between any two active neurons.
(2) By evaluating the derivative of the presented segulanies w.r.t. the activation, we get:

ORsxz( MN)
_ nn A
ann 7M “)

i.e., each active neuron receives a penalty from every other active neuron that corresponds to that
other neuron’s activation magnitude. In other words, if a neuron fires, with a high activation value,
for a given example, it will suppress firing of other neurons for that same example. Hence, this results
in a decorrelated sparse representation.

 

3.2 SPARSE CODING THROUGH LOCAL NEURAL INHIBITION (SLNI)

The loss imposed by the SNI objective will only be zero when there is at most one active neuron
per example. This seems to be too harsh for complex tasks that need a richer representation. Thus,
we suggest to relax the objective by imposing a spatial weighting to the correlation penalty. In other
words, an active neuron penalizes mostly its close neighbours and this effect vanishes for neurons
further away. Instead of uniformly penalizing all the correlated neurons, we weight the correlation
penalty between two neurons with locations i and j using a Gaussian weighting. This gives

1 -ey =i" npn
Rsunt (Hi) = mye “ret Soh! hj i#j (5)

m
Published as a conference paper at ICLR 2019

 

As such, each active neuron inhibits its neighbours, introducing a locality in the network inspired
by biological neurons. While the notion of neighbouring neurons is not well established in a fully
connected network, our aim is to allow few neurons to be active and not only one, thus those few
activations don’t have to be small to compensate for the penalty. o? is a hyper parameter representing
the scale at which neurons can affect each other. Note that this is somewhat more flexible than
decorrelating neurons in fixed groups as used in[Xiong et al.|( Our regularizer inhibits locally
the active neurons leading to a sparse coding through local neural inhibition.

 

3.3. NEURON IMPORTANCE FOR DISCOUNTING INHIBITION

Our regularizer is to be applied for each task in the learning sequence. In the case of tasks with
completely different input patterns, the active neurons of the previous tasks will not be activated given
the new tasks input patterns. However, when the new tasks are of similar or shared patterns, neurons
used for previous tasks will be active. In that case, our penalty would discourage other neurons from
being active and encourage the new task to adapt the already active neurons instead. This would
interfere with the previous tasks and could increase forgetting which is exactly what we want to
overcome. To avoid such interference, we add a weight factor taking into account the importance of
the neurons with respect to the previous tasks. To estimate the importance of the neurons, we use as a
measure the sensitivity of the loss at the end of the training to their changes. This is approximated by
the gradients of the loss w.r.t. the neurons outputs (before the activation function) evaluated at each
data point. To get an importance value, we then accumulate the absolute value of the gradients over
the given data points obtaining importance weight a; for neuron n;:

M
_i : _ WLY ms f(&m+")))
a= Mu » |gi(@m) |, gi(tm) = nn (6)

m=

 

where n" is the output of neuron n; for a given input example x,,,, and 6” are the parameters after
learning task n. This is in line with the estimation of the parameters importance in[Kirkpatrick etal]

but considering the derivation variables to be the neurons outputs instead of the parameters.
Instead of relying on the gradient of the loss, we can also use the gradient of the learned function, i.e.
the output layer, as done in{ATjundi et al.](2017) for estimating the parameters importance. During the
early phases of this work, we experimented with both and observed a similar behaviour. For sake of
consistency and computational efficiency we utilize the gradient of the function when usin;
) as LLL method and the gradient of the loss when experimenting with EWC (
Then, we can weight our regularizer as follows:

     

64)?

Rexnto (Hh) = Z Srerlatade SE STH, tj (7)
J m

which can be read as: if an important neuron for a previous task is active given an input pattern from

the current task, it will not suppress the other neurons from being active neither be affected by other

active neurons. For all other active neurons, local inhibition is deployed. The final objective for

training is given in Eq. |2| setting Rggrz := Reivrp and Assi := Asunip. We refer to our full method

as Sparse coding through Local Neural Inhibition and Discounting (SLNID).

 

4 EXPERIMENTS

In this section we study the role of standard regularization techniques with a focus on sparsity and
decorrelation of the representation in a sequential learning scenario. We first compare different
activation functions and regularization techniques, including our proposed SLNID, on permuted
MNIST (Sec. Then, we compare the top competing techniques and our proposed method in
the case of sequentially learning CIFAR-100 classes and Tiny Imagenet classes (Sec. 2p. Our
SLNID regularizer can be integrated in any importance weight-based lifelong learning approach such

as ( -| 2017} [Aljundi et al-] 2017). Here we focus on Memory

(MAS), which is easy to integrate and experiment with and

 

 
 
  

(Sec. (5). Finally, we show how our regularizer improves the state-of-the-art performance on a
sequence of object recognition tasks (Sec. [4.6}.
Published as a conference paper at ICLR 2019

a8 1) D4 Tale
Tl T2 3 v4 1S

Figure 2: Comparison of different regularization techniques on 5 permuted MNIST sequence. Representation
based regularizers are solid bars, bars with lines represent parameters regularizers, dotted bars represent activation
functions. Average test accuracy over all tasks is given in the legend. Representation based regularizers achieve
higher performance than other compared methods including parameters based regularizers. Our regularizer,
SLNID, performs the best on the last two tasks indicating that more capacity is left to learn these tasks.

 

 

SLNID:95.83
DeCov:95.68
L1-Rep:95.81
OrthReg:93.99
L1_Param:92.68
12_w0:92.91
Maxout:92.85
LWTA:92.85
ReLU:92.52

s 8 &
GERTTOEEE

Accuracy % after learning all tasks

4.1 AN IN-DEPTH COMPARISON OF REGULARIZERS AND ACTIVATION FUNCTIONS FOR
SELFLESS SEQUENTIAL LEARNING

We study possible regularization techniques that could lead to less interference between the different
tasks in a sequential learning scenario either by enforcing sparsity or decorrelation. Additionally, we
examine the use of activation functions that are inspired by lateral inhibition in biological neurons
that could be advantageous in sequential learning. MAS[Aljundi et al} is used in all cases as
LLL method.

Representation Based methods:

- L1-Rep: To promote representational sparsity, an L; penalty on the activations is used.

-Decov aims at reducing overfitting by decorrelating neuron activations. To
do so, it minimizes the Frobenius norm of the covariance matrix computed on the activations of the
current batch after subtracting the diagonal to avoid penalizing independent neuron activations.
Activation functions:

-Maxout network (Goodfellow et al-|/2013b) utilizes the maxout activation function. For each group
of neurons, based on a fixed window size, only the maximum activation is forwarded to the next layer.
The activation function guarantees a minimum sparsity rate defined by the window size.

- LWTA similar idea to the Maxout network except that the non-maximum
activations are set to zero while maintaining their connections. In contrast to Maxout, LWTA keeps
the connections of the inactive neurons which can be occupied later once they are activated without
changing the previously active neuron connections.

- ReLU The rectifier activation function (ReLU) used as a baseline here and
indicated in later experiments as No—Reg as it represents the standard setting of sequential learning
on networks with ReLU. All the studied regularizers use ReLU as activation function.

Parameters based regularizers:

- OrthReg (Rodriguez et al.|/2016): Regularizing CNNs with locally constrained decorrelations. It
aims at decorrelating the feature detectors by minimizing the cosine of the angle between the weight
vectors resulting eventually in orthogonal weight vectors.

- L2-WD: Weight decay with Ly norm controls the complexity of the learned
function by minimizing the magnitude of the weights.

- L1-Param: L penalty on the parameters to encourage a solution with sparse parameters.

  

 

 

 

 

Dropout is not considered as its role contradicts our goal. While dropout can improve each task
performance and reduce overfitting, it acts as a model averaging technique. By randomly masking
neurons, dropout forces the different neurons to work independently. As such it encourages a
redundant representation. As shown by [2013a) the best network size for classifying
MNIST digits when using dropout was about 50% more than without it. Dropout steers the learning
of a task towards occupying a good portion of the network capacity, if not all of it, which contradicts
the sequential learning needs.

Experimental setup. We use the MNIST dataset (LeCun et al.|{1998) as a first task in a sequence of
5 tasks, where we randomly permute all the input pixels differently for tasks 2 to 5. The goal is to

classify MNIST digits from all the different permutations. The complete random permutation of the
pixels in each task requires the neural network to instantiate a new neural representation for each
pattern. A similar setup has been used by|Kirkpatrick et al.|(2016);/Zenke et al. 2017); Goodfellow|

with different percentage of permutations or different number of tasks.
As a base network, we employ a multi layer perceptron with two hidden layers and a Softmax loss.

 
Published as a conference paper at ICLR 2019

 

 

mmm SLNID:63.3 mE DeCov:61.19 mmm L1-Rep:55.76 mam No-Reg55.31 mE SLNID:53.96 mE DeCov:52.47 mmm L1-Rep:52.57 mm No-Reg:49.56

$50
S
I, bas
240
mow a a

12 13. 1475

‘Accuracy % after learning all tasks

Figure 3: Comparison of different regularization techniques on a sequence of ten tasks from (a) Cifar split and
(b) Tiny ImageNet split. The legend shows average test accuracy over all tasks. Simple L1-norm regularizer
(L1-Rep) doesn’t help in such more complex tasks. Our regularizer SLNID achieves an improvement of 2%
over Decov and 4 — 8% compared to No-Reg.

We experiment with different number of neurons in the hidden layers {128,64}. For SLNID we
evaluate the effect of Asirp on the performance and the obtained sparsity in Figur In general, the
best Asinrp is the minimum value that maintains similar or better accuracy on the first task compared
to the unregularized case, and we suggest to use this as a rule-of-thumb to set Asinrp. For Ae, we
have used a high Ap value that ensures the least forgetting which allows us to test the effect on the
later tasks performance. Note that better average accuracies can be obtained with tuned Aq. Please
refer to Appendix[A]for hyperparameters and other details.

 

Results: Figure}2|presents the test accuracy on each task at the end of the sequence, achieved by the
different regularizers and activation functions on the network with hidden layer of size 128. Results
on a network with hidden layer size 64 are shown in the Appendix [B] Clearly, in all the different
tasks, the representational regularizers show a superior performance to the other studied techniques.
For the regularizers applied to the parameters, L2—WD and L1—Param do not exhibit a clear trend
and do not systematically show an improvement over the use of the different activation functions only.
While OrthReg shows a consistently good performance, it is lower than what can be achieved by
the representational regularizers. It is worth noting the L1—Rep yields superior performance over
L1—Param. This observation is consistent across different sizes of the hidden layers (in Appendix [Bp
and shows the advantage of encouraging sparsity in the activations compared to that in the parameters.
Regarding the activation functions, Maxout and LWTA achieve a slightly higher performance than
ReLU. We did not observe a significant difference between the two activation functions. However,
the improvement over ReLU is only moderate and does not justify the use of a fixed window size
and special architecture design. Our proposed regularizer SLNID achieves high if not the highest
performance in all the tasks and succeeds in having a stable performance. This indicates the ability of
SLNID to direct the learning process towards using minimum amount of neurons and hence more
flexibility for upcoming tasks.

Representation sparsity & important parameter sparsity.

aww = 0.02
aeeoi.a4
Dau = 0.005
pecans
Daag ™ 0.002

Here we want to examine the effect of our regularizer on the
percentage of parameters that are utilized after each task and
hence the capacity left for the later tasks. On the network with
hidden layer size 128, we compute the percentage of parameters
with Q, < 10~?, with Q,, see Appendix [A] the importance
weight multiplier estimated and accumulated over tasks. Those
parameters can be seen as unimportant and "free" for later
tasks. Figure[4] top) shows the percentage of the unimportant
(free) parameters in the first layer after each task for different
Asinitp Values along with the achieved average test accuracy ea
at the end of the sequence. It is clear that the larger Astytp, 44
i.e., the more neural inhibition, the smaller the percentage of 30)
important parameters. Apart from the highest Aszyrp where aa
tasks couldn’t reach their top performance due to too strong .
inhibition, improvement over the No—Reg is always observed. wee
The optimal value for lambda seems to be the one that remains Figure 4: On the 5 permuted MNIST
close to the optimal performance on the current task, while Sequence, hidden layer=128, Top: per-
utilizing the minimum capacity feasible. Next, we compute _©&Mage of unused parameters in the Ist
the average activation per neuron, in the first layer, over all ayer using different Asiv:0; Bottom:
x : histogram of neural activations on the
the examples and plot the corresponding histogram for SLNID, goo tack
DeCov, L1-Rep, L1-Param and No-Reg in Figure[4{bot- ,
tom) at their setting that yielded the results shown in Figure] SLNID has a peak at zero indicating
representation sparsity while the other methods values are spread along the line. This seems to hint at

aces.
Asaig = 9.0005

aces 34
aap = 0,002,
acces
No Reg

* gcci92 52

Parmeters Sparsity %

  

 

 
Published as a conference paper at ICLR 2019

 

 

 

 

 

 

 

 

 

 

 

 

 

 

the effectiveness of our approach SLNID in learning a sparse yet powerful representation and in turn

in a minimal interference between tasks.

| Permuted mnist Cifar | Method Avg-ace |

| h-layer dim. 128 | 64 256 | 128 Finetune 32.67

[No-Reg 92.67 [90.72 [55.06 [55.3 49.49
SNI 95.79 | 94.89 | 55.30] 55.75 50.29
SNID 95.90 | 93.82 | 61.00 | 60.90 43.4
SLNI 95.95| 94.87 | 56.06 | 55.79 50.49
SLNID 95.83 | 93.89 | 63.30 | 61.16 50.00

[ Multi-Task Joint Training* [97.30 [96.80 _ [70.99 [71.95 re

Table 1: SLNID ablation. Average test accuracy per SLNTD-fe randomly initialized (ours) | 54.50

task after training the last task in %. * denotes that Multi- . .

Task Joint Training violates the LLL scenario as it has Table 2: 8 tasks object recognition se-
access to all tasks at once and thus can be seen as an quence. Average test accuracy per task
upper bound. after training the last task in %.

4.2. 10 TASK SEQUENCES ON CIFAR-100 AND TINY IMAGENET

 

While the previous section focused on learning a sequence of tasks with completely different input
patterns and same objective, we now study the case of learning different categories of one dataset.
For this we split the CIFAR-100 and the Tiny Eni geDiet (725 Se Milled (2015) dataset into ten tasks,
respectively. We have 10 and 20 categories per task for AR- and Tiny ImagNet, respectively.
Further details about the experimental setup can be found in appendix [A]

We compare the top competing methods from the previous experiments, L1—Rep, DeCov and our

SLNID, and No-Reg as a baseline, ReLU in previous experiment. Similarly, MAS [ATjundi et al]
is used in all cases as LLL method. Figures[3[a) and[3{b) show the performance on each of the

ten tasks at the end of the sequence. For both datasets, we observe that our SLNID performs overall

best. L1-Rep and DeCov continue to improve over the non regularized case No—Reg. These results

confirm our proposal on the importance of sparsity and decorrelation in sequential learning.

4.3. SLNID WITH EWC 2016)

We have shown that our proposed regularizer SLNID exhibits stable and superior performance on
the different tested networks when using MAS as importance weight preservation method. To prove
the effectiveness of our regularizer regardless of the used importance weight based method, we
have tested SLNID on the 5 tasks permuted MNIST sequence in combination with Elastic Weight
Consolidation (EWwC|Kirkpatrick et al.| and obtained a boost in the average performance at
the end of the learned sequence equal to 3.1% on the network with hidden layer size 128 and a
boost of 2.8% with hidden layer size 64. Detailed accuracies are shown in Appendix|B} It is worth
noting that with both MAS and EWC our SLNID was able obtain better accuracy using a network with
a 64-dimensional hidden size than when training without regularization No—Reg on a network of
double that size (128), indicating that SLNID allows to use neurons much more efficiently.

  
 

4.4 ABLATION STUDY

Our method can be seen as composed of three components: the neural inhibition, the locality relax-
ation and the neuron importance integration. To study how these components perform individually,
Table [I] reports the average accuracy at the end of the Cifar 100 and permuted MNIST sequences
for each variant, namely, SNID without neuron importance (SNI), SNID, SLNID without neuron
importance (SLNT) in addition to our full SLNID regularizer. As we explained in Section} when
tasks have completely different input patterns, the neurons that were activated on the previous task
examples will not fire for new task samples and exclusion of important neurons is not mandatory.
However, when sharing is present between the different tasks, a term to prevent SLNID from causing
any interference is required. This is manifested in the reported results: for permuted MNIST, all
the variants work nicely alone, as a result of the simplicity and the disjoint nature of this sequence.
However, in the Cifar 100 sequence, the integration of the neuron importance in the SNID and SLNID
Published as a conference paper at ICLR 2019

 

regularizers exclude important neurons from the inhibition, resulting in a clearly better performance.
The locality in SLNID improves the performance in the Cifar sequence, which suggests that a richer
representation is needed and multiple active neurons should be tolerated.

4.5 SEQUENTIAL LEARNING WITHOUT HARD TASK BOUNDARIES

 

In the previous experiments, we considered the standard task based scenario as in
Zenke et al.| 2017} Aljundi et al. 2017] Serra et al. 2018), where at each time step we receive a task
along with its training data and a new classification layer is initiated for the new task, if needed. Here,
we are interested in a more realistic scenario where the data distribution shifts gradually without hard
task boundaries.

To test this setting, we use the Cifar 100 dataset. Instead

 

 

of considering a set of 10 disjoint tasks each composed of [Method Avg.ace -tasks models
10 classes, as in the previous experiment (Sec. , we now poe MAS oa
: : : “a 9 SLNI w/o MAS - Io
start by sampling with high probability (2/3) from the first | soutpwyo mas | 73.03%
10 classes and with low probability (1/3) from the rest of the | No-Reg 66.88%
classes. We train the network (same architecture as in Sec a ees
33%

 

 

for a few epochs and then change the sampling probabilities

 

 

 

 

 

Method Avg.acc-last model |

to be high (2/3) for classes 11 — 20 and low (1/3) for the [\o-Regu7o WAS T-65.15%
remaining classes. This process is repeated until sampling | SLNIw/o mas 63.54%
with high probability from the last 10 classes and low from the — MAS oor
rest. We use one shared classification layer throughout and esti- | sit 64.50%
mate the importance weights and the neurons importance after [|_SLNID 70.94%

 

each training step (before changing the sampling probabilities). .
We consider 6 variants: our SLNID, the ablations SLNI and Table 3: No tasks boundaries test case
without regularizer No-Reg, as in Section[4.4] as well each 07 Cifar 100. Top block, avg. acc on
of these three trained without the MAS importance weight cach eroup oF classes Using each group
: model. Bottom block, avg. acc. on each
regularizer of[Aljundi et al.|(2017), denoted as w/o MAS. Ta- group at the end of the training.
ble[]presents the accuracy averaged over the ten groups of ten
classes, using each group model (i.e. the model trained when this group was sampled with high prob-
ability) in the top block and the average accuracy on each of the ten groups at the end of the training
(middle and bottom block). We can deduce the following: 1) SLNID improves the performance
considerably (by more than 4%) even without importance weight regularizer. 2) In this scenario
without hard task boundaries there is less forgetting than in the scenario with hard task boundaries
studied in Section|4.2]for Cifar (difference between rows in top block to corresponding rows in middle
block). As a result, the improvement obtained by deploying the importance weight regularizer is
moderate: at 70.75%, SLNID w/o MAS is already better than No—Reg reaching 66.33%. 3) While
SLNI without MAS improves the individual models performance (72.14% compared to 69.20%), it
fails to improve the overall performance at the end of the sequence (63.54% compared to 65.15%), as
important neurons are not excluded from the penalty and hence they are changed or inhibited leading
to tasks interference and performance deterioration.

4.6 COMPARISON WITH THE STATE OF THE ART

To compare our proposed approach with the different state-of-the-art sequential learning methods,

we use a sequence of 8 different object recognition tasks, introduced in (2017). The
sequence starts from AlexNet (Krizhevsky et al.| (2012) pretrained on ImageNet (Russakovsky|
(2015) as a base network, following the setting 0: (2017). More details are in
Appendix|A.4] We compare against the following: Learning without Forgetting (Li & Hoiem| 2016)
(LwF), Incremental Moment Matching (Lee et al.||2017) (IMM), Path Integral (Zenke et al.}/2017) and
sequential finetuning (F ineTuning), in addition to the case of MAS (Aljundi et al.|/2017) alone, i.e.
our No-Reg before. Compared methods were run with the exact same setup as in
(2017). For our regularizer, we disable dropout, since dropout encourages redundant activations
which contradicts our regularizer’s role. Also, since the network is pretrained, the locality introduced
in SLNID may conflict with the already pretrained activations. For this reason, we also test SLNID
with randomly initialized fully connected layers. Our regularizer is applied with MAS as a sequential
learning method. Table 2|reports the average test accuracy at the end of the sequence achieved by
each method. SLNID improves even when starting from a pretrained network and disabling dropout.

      
         
     

 
Published as a conference paper at ICLR 2019

 

Surprisingly, even with randomly initialized fully connected layers, SLNID improves 1.8% over the
state of the art using a fully pretrained network.

5 CONCLUSION

In this paper we study the problem of sequential learning using a network with fixed capacity — a
prerequisite for a scalable and computationally efficient solution. A key insight of our approach is
that in the context of sequential learning (as opposed to other contexts where sparsity is imposed,
such as network compression or avoiding overfitting), sparsity should be imposed at the level of the
representation rather than at the level of the network parameters. Inspired by lateral inhibition in
the mammalian brain, we impose sparsity by means of a new regularizer that decorrelates nearby
active neurons. We integrate this in a model which learns selflessly a new task by leaving capacity
for future tasks and at the same time avoids forgetting previous tasks by taking into account neurons
importance.

Acknowledgment: The first author’s PhD is funded by an FWO scholarship.

REFERENCES

Alireza Aghasi, Afshin Abdi, Nam Nguyen, and Justin Romberg. Net-trim: Convex pruning of deep neural
networks with performance guarantee. In Advances in Neural Information Processing Systems, pp. 3180-3189,
2017.

Rahaf Aljundi, Punarjay Chakravarty, and Tinne Tuytelaars. Expert gate: Lifelong learning with a network of
experts. In JEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2016.

Rahaf Aljundi, Francesca Babiloni, Mohamed Elhoseiny, Marcus Rohrbach, and Tinne Tuytelaars. Memory
aware synapses: Learning what (not) to forget. arXiv preprint arXiv:1711.09601, 2017.

Yoshua Bengio et al. Learning deep architectures for ai. Foundations and trends) in Machine Learning, 2(1):
1-127, 2009.

Arslan Chaudhry, Puneet K Dokania, Thalaiyasingam Ajanthan, and Philip HS Torr. Riemannian walk for
incremental learning: Understanding forgetting and intransigence. arXiv preprint arXiv:1801.10112, 2018.

Michael Cogswell, Faruk Ahmed, Ross Girshick, Larry Zitnick, and Dhruv Batra. Reducing overfitting in deep
networks by decorrelating representations. arXiv preprint arXiv: 1511.06068, 2015.

T. E. de Campos, B. R. Babu, and M. Varma. Character recognition in natural images. In Proceedings of the
International Conference on Computer Vision Theory and Applications, Lisbon, Portugal, February 2009.

M. Everingham, L. Van Gool, C. K. I. Williams, J. Winn, and A. Zisserman. The PAS-
CAL Visual Object Classes Challenge 2012 (VOC2012) Results. http://www.pascal-
network.org/challenges/VOC/voc2012/workshop/index.html.

Chrisantha Fernando, Dylan Banarse, Charles Blundell, Yori Zwols, David Ha, Andrei A Rusu, Alexander
Pritzel, and Daan Wierstra. Pathnet: Evolution channels gradient descent in super neural networks. arXiv
preprint arXiv: 1701.08734, 2017.

Robert M French. Semi-distributed representations and catastrophic forgetting in connectionist networks.
Connection Science, 4(3-4):365-377, 1992.

Robert M French. Dynamically constraining connectionist networks to produce distributed, orthogonal represen-
tations to reduce catastrophic interference. network, 1111:00001, 1994.

Robert M French. Catastrophic forgetting in connectionist networks. Trends in cognitive sciences, 3(4):128-135,
1999.

Xavier Glorot, Antoine Bordes, and Yoshua Bengio. Deep sparse rectifier neural networks. In Geoffrey Gordon,
David Dunson, and Miroslav Dudik (eds.), Proceedings of the Fourteenth International Conference on
Artificial Intelligence and Statistics, volume 15 of Proceedings of Machine Learning Research, pp. 315-323,

Fort Lauderdale, FL, USA, 11-13 Apr 2011. PMLR. URL/http://proceedings.mlr.press/v15

Ian J Goodfellow, Mehdi Mirza, Da Xiao, Aaron Courville, and Yoshua Bengio. An empirical investigation of
catastrophic forgetting in gradient-based neural networks. arXiv preprint arXiv:1312.6211, 2013a.

10
Published as a conference paper at ICLR 2019

 

Ian J Goodfellow, David Warde-Farley, Mehdi Mirza, Aaron Courville, and Yoshua Bengio. Maxout networks.
arXiv preprint arXiv: 1302.4389, 2013b.

DO Hebb. The organization of behavior. 1949. New York Wiely, 2002.

James Kirkpatrick, Razvan Pascanu, Neil Rabinowitz, Joel Veness, Guillaume Desjardins, Andrei A Rusu,
Kieran Milan, John Quan, Tiago Ramalho, Agnieszka Grabska-Barwinska, et al. Overcoming catastrophic
forgetting in neural networks. arXiv preprint arXiv:1612.00796, 2016.

Jonathan Krause, Michael Stark, Jia Deng, and Li Fei-Fei. 3d object representations for fine-grained categoriza-
tion. In Proceedings of the IEEE International Conference on Computer Vision Workshops, pp. 554-561,
2013.

Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classification with deep convolutional
neural networks. In F. Pereira, C. J. C. Burges, L. Bottou, and K. Q. Weinberger (eds.), Advances in Neural
Information Processing Systems 25, pp. 1097-1105. Curran Associates, Inc., 2012.

Anders Krogh and John A Hertz. A simple weight decay can improve generalization. In Advances in neural
information processing systems, pp. 950-957, 1992.

John K Kruschke. Alcove: an exemplar-based connectionist model of category learning. Psychological review,
99(1):22, 1992.

John K Kruschke. Human category learning: Implications for backpropagation models. Connection Science, 5
(1):3-36, 1993.

Yann LeCun, Léon Bottou, Yoshua Bengio, and Patrick Haffner. Gradient-based learning applied to document
recognition. Proceedings of the IEEE, 86(11):2278-2324, 1998.

Sang-Woo Lee, Jin-Hwa Kim, Jung-Woo Ha, and Byoung-Tak Zhang. Overcoming catastrophic forgetting by
incremental moment matching. arXiv preprint arXiv:1703.08475, 2017.

Peter Lennie. The cost of cortical computation. Current biology, 13(6):493-497, 2003.

Zhizhong Li and Derek Hoiem. Learning without forgetting. In European Conference on Computer Vision, pp.
614-629. Springer, 2016.

Baoyuan Liu, Min Wang, Hassan Foroosh, Marshall Tappen, and Marianna Pensky. Sparse convolutional neural
networks. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp. 806-814,
2015.

Xialei Liu, Mare Masana, Luis Herranz, Joost Van de Weijer, Antonio M Lopez, and Andrew D Bagdanov. Rotate
your networks: Better weight consolidation and less catastrophic forgetting. arXiv preprint arXiv: 1802.02950,
2018.

David Lopez-Paz et al. Gradient episodic memory for continual learning. In Advances in Neural Information
Processing Systems, pp. 6470-6479, 2017.

Christos Louizos, Karen Ullrich, and Max Welling. Bayesian compression for deep learning. In Advances in
Neural Information Processing Systems, pp. 3290-3300, 2017.

S. Maji, J. Kannala, E. Rahtu, M. Blaschko, and A. Vedaldi. Fine-grained visual classification of aircraft.
Technical report, 2013.

Arun Mallya and Svetlana Lazebnik. Packnet: Adding multiple tasks to a single network by iterative pruning.
arXiv preprint arXiv:1711.05769, 1(2):3, 2017.

Yuval Netzer, Tao Wang, Adam Coates, Alessandro Bissacco, Bo Wu, and Andrew Y Ng. Reading digits in
natural images with unsupervised feature learning. 2011.

M-E. Nilsback and A. Zisserman. Automated flower classification over a large number of classes. In Proceedings
of the Indian Conference on Computer Vision, Graphics and Image Processing, Dec 2008.

Ariadna Quattoni and Antonio Torralba. Recognizing indoor scenes. In Computer Vision and Pattern Recognition,
2009. CVPR 2009. IEEE Conference on, pp. 413-420. IEEE, 2009.

Pau Rodriguez, Jordi Gonzalez, Guillem Cucurull, Josep M Gonfaus, and Xavier Roca. Regularizing cnns with
locally constrained decorrelations. arXiv preprint arXiv:1611.01967, 2016.

11
Published as a conference paper at ICLR 2019

 

Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjeev Satheesh, Sean Ma, Zhiheng Huang, Andrej
Karpathy, Aditya Khosla, Michael Bernstein, Alexander C. Berg, and Li Fei-Fei. ImageNet Large Scale
Visual Recognition Challenge. International Journal of Computer Vision (IJCV), 115(3):211-252, 2015. doi:
10.1007/s11263-015-0816-y.

Andrei A Rusu, Neil C Rabinowitz, Guillaume Desjardins, Hubert Soyer, James Kirkpatrick, Koray Kavukcuoglu,
Razvan Pascanu, and Raia Hadsell. Progressive neural networks. arXiv preprint arXiv: 1606.04671, 2016.

Joan Serra, Didac Suris, Marius Miron, and Alexandros Karatzoglou. Overcoming catastrophic forgetting with
hard attention to the task. arXiv preprint arXiv: 1801.01423, 2018.

Karen Simonyan and Andrew Zisserman. Very deep convolutional networks for large-scale image recognition.
arXiv preprint arXiv:1409.1556, 2014.

Steven A Sloman and David E Rumelhart. Reducing interference in distributed memories through episodic
gating. Essays in honor of WK Estes, 1:227-248, 1992.

Rupesh K Srivastava, Jonathan Masci, Sohrob Kazerounian, Faustino Gomez, and Jiirgen Schmidhuber. Compete
to compute. In C. J. C. Burges, L. Bottou, M. Welling, Z. Ghahramani, and K. Q. Weinberger (eds.),
Advances in Neural Information Processing Systems 26, pp. 2310-2318. Curran Associates, Inc., 2013. URL

 

Yi Sun, Xiaogang Wang, and Xiaoou Tang. Sparsifying neural network connections for face recognition. In
Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pp. 4856-4864, 2016.

Sebastian Thrun and Tom M Mitchell. Lifelong robot learning. Robotics and autonomous systems, 15(1-2):
25-46, 1995.

Amal Rannen Triki, Rahaf Aljundi, Mathew B Blaschko, and Tinne Tuytelaars. Encoder based lifelong learning.
arXiv preprint arXiv:1704.01920, 2017.

P. Welinder, S. Branson, T. Mita, C. Wah, F. Schroff, S. Belongie, and P. Perona. Caltech-UCSD Birds 200.
Technical Report CNS-TR-2010-001, California Institute of Technology, 2010.

Wei Xiong, Bo Du, Lefei Zhang, Ruimin Hu, and Dacheng Tao. Regularizing deep convolutional neural networks
with a structured decorrelation constraint. In JCDM, pp. 519-528, 2016.

Jian Xue, Jinyu Li, and Yifan Gong. Restructuring of deep neural network acoustic models with singular value
decomposition. In Interspeech, pp. 2365-2369, 2013.

Leon Yao and John Miller. Tiny imagenet classification with convolutional neural networks. CS 231N, 2015.

Yuguo Yu, Michele Migliore, Michael L Hines, and Gordon M Shepherd. Sparse coding and lateral inhibition
arising from balanced and unbalanced dendrodendritic excitation and inhibition. Journal of Neuroscience, 34
(41):13701-13713, 2014.

Friedemann Zenke, Ben Poole, and Surya Ganguli. Improved multitask learning through synaptic intelligence.
In Proceedings of the International Conference on Machine Learning (ICML), 2017.

12
Published as a conference paper at ICLR 2019

 

APPENDIX

A DETAILS ON THE EXPERIMENTAL SETUP

In all designed experiments, our regularizer is applied to the neurons of the fully connected layers. As a future
work, we plan to integrate it in the convolutional layers.

A.1 PERMUTED MNIST

The used network is composed of two fully connected layers. All tasks are trained for 10 epochs with a learning
rate 10~? using SGD optimizer. ReLU is used as an activation function unless mentioned otherwise. Throughout
the experiment, we used a scale o for the Gaussian function used for the local inhibition equal to 1/6 of the
hidden layer size. For all competing regularizers, we tested different hyper parameters from 10~? to 10~° and
report the best one. For Ao, we have used a high Ae value that ensures the least forgetting. This allows us to
examine the degradation in the performance on the later tasks compared to those learned previously as a result of
lacking capacity. Note that better average accuracies can be obtained with tuned Ao.

In section[4.1]we estimated the free capacity in the network with the percentage of Q, < 1077, with Q,, the
importance weight multiplier estimated and accumulated over tasks. We consider 2, < 10~? of negligible
importance as in a network trained without a sparsity regularizer, Qi; < 107? covers the first 10 percentiles.

A.2 CIFAR-100

As a base network, we use a network similar to the one used by |Zenke et al.|( but without dropout. We
evaluate two variants with hidden size N = {256, 128}. Throughout the experiment, we again used a scale 7
for the Gaussian function equal to 1/6 of the hidden layer size. We train the different tasks for 50 epochs with a
learning rate of 10~? using SGD optimizer.

 

A.3 Tiny IMAGENET

 

 

 

We split the Tiny ImageNet dataset ( (Yao & Miller] ae ei tasks, each ——, twenty categories to be
learned at once. As a base network, we use a oe 0} . For architecture
details, please refer to Table[4]below.

Layer # filters/neurons

Convolution 64

Max Pooling -

Convolution 128

Max Pooling -

Convolution 256

Max Pooling -

Convolution 256

Max Pooling

Convolution 512

Convolution 512

Fully connected | 500

Fully connected | 500

Fully connected | 20

 

 

 

 

Table 4: Architecture of the network used in the Tiny Imagenet experiment.

Throughout the experiment, we again used a scale o for the Gaussian function equal to 1/6 of the hidden layer
size.

A.4 8 TASK OBJECT RECOGNITION SEQUENCE

 
    
   
  

 
   

   
    
    

      
 

The 8 ta ence is composed of: 1. Oxford Flowers (2008), 2. MIT Scenes

. Caltech-UCSD Birds (Welinder et al.]|2010), 4. Stanford Cars (Krause et al.| DY
FGVC-Aircraft j 6. VOC Actions (Everingham et al.);7. Letters
[2009); and 8. SVHN atasets. We have rerun the different methods and obtain the same

      
 

 
    

reported results as in

Aljundi et

13
Published as a conference paper at ICLR 2019

 

B_ EXTRA RESULTS

B.1 PERMUTED MNIST SEQUENCE

In section[4.T] we have studied the performance of different regularizers and activation functions on 5 permuted
Mnist tasks in a network with a hidden layer of size 128. Figure|5|shows the average accuracies achieved by each
of the studied methods at the end of the learned sequence in a network with a hidden layer of size 64. Similar
conclusions can be drawn. Maxout and LWTA perform similarly and improve slightly over ReLU. Regularizers
applied to the representation are more powerful for sequential learning than regularizers applied directly to the
parameters. Specifically, L1-Rep (orange) is consistently better than L1-Param (pink). Our SLNID is able of
maintaining a good performance on all the tasks, achieving among the top average test accuracies. Admittedly,
the performances of SLNID is very close to LI-Rep. The difference between these methods stands out more
clearly for larger networks and more complex tasks.

     

 

SLNID:93.89
DeCov:93.58
Li Rep:93.85
OrthReg:92.65
La_Param:91.06
L2_wD:90.99
Maxout:91.52
LWTA:91.22
RelU:90.72

96

0
°
:
3
Tl T2 TB T4 TS

Figure 5: Comparison of different regularization techniques on 5 permuted MNIST sequence of tasks, hidden
size=64. Representation based regularizers are solid bars, bars with lines represent parameters regularizers,
dotted bars represent activation functions. See Figure2}for size 128.

all tasks

 

Accuracy % after learni

 

 

 

B.2. SLNI wirH EWC

To show that our approach is not limited to Mas (Aljundi et al.] , we have also experimented with
EWC ) as another importance weight based method along with our regularize SLNID
on the permuted Mnist sequence. Figure[6]shows the test accuracy of each task at the end of the 5 permuted
Mnhist sequence achieved by our SLNID combined with EWC and by No-Reg (here indicating EWC without
regularization). It is clear that SLNID succeeds to improve the performance on all the learned tasks which
validates the utility of our approach with different sequential learning methods.

 

 

 

mE SLNID:96.98 mam NoReg:94.12 mmm No-Reg:92.26

| | | | SLNID-95.86
TL 2 3. Th TS. TL 2 3 Ta TS.

Figure 6: (a) SLNID with EWC on 5 permuted Mnist sequence of tasks, hidden size=128, (b) hidden size=64.

Accuracy % after learning all tasks

 

B.3. CIFAR 100 SEQUENCE

In section |4.2] we have tested SLNID and other representation regularizers on the Cifar 100 sequence. In
Figure[3] .) we compare their performance on a network with hidden layer size 256. Figure[7]repeats the same
experiment for a network with hidden size 128. While DeCov and SLNID continue to improve over No-Reg,
L1-Rep seems to suffer in this case. Our interpretation is that L1—Rep here interferes with the previously
learned tasks while penalizing activations and hence suffers from catastophic forgetting. In line with all the
previous experiments SLNID achieves the best accuracies and manages here to improve over 6% compared to
No-Reg.

14
Published as a conference paper at ICLR 2019

 

~
S

 

@mm SLNID:61.16 @mm DeCov:58.43 @m L1-Rep:52.61 f@@@™ No-Reg:55.06

a
a

a
So

wi
a

w
°

S
a

 

 

 

Accuracy % after learning all tasks

S
3

TL T2 T3 T4 TS T6 7 Ts T9 T10

Figure 7: Comparison of different regularization techniques on a sequence of ten tasks from Cifar split. Hidden
size=128. See Figure[[a) for size 256.

B.4 SPATIAL LOCALITY TEST

To avoid penalizing all the active neurons, our SLNID weights the correlation penalty between each two neurons
based on their spatial distance using a Gaussian function. We want to visualize the effect of this spatial locality
on the neurons activity. To achieve this, we have used the first 3 tasks of the Permuted Mnist sequence as a test
case and visualized the neurons importance after each task. This is done using the network of hidden layer size
64. Figure[8} Figure[9]and Figure how the neurons importance after each task. The left column is without
locality, i.e. SLNID, and the right column is SLNID. Blue represents the first task, orange the second task and
green the third task. When using SLNTID, inhibition is applied in a local manner allowing more active neurons
which could potentially improve the representation power. When learning the second task, new neurons become
important regardless of their closeness to first task important neurons as those neurons are excluded from the
inhibition. As such, new neurons are becoming active as new tasks are learned. For SLNID all neural correlation
is penalized in the first task. And for later tasks, very few neurons are able to become active and important for
the new task due to the strong global inhibition, where previous neurons that are excluded from the inhibition
are easier to be re-used.

 

15
Published as a conference paper at ICLR 2019

 

 

 

1.0 ° 101°

og

06

°
0.4 °

B

Neurons Importance

02 ‘

°
0.0 | cscee0 essse Seo co cassse cosse © cece “estes ® ennso ase ose

 

 

 

0 10 20 30 40

Neurons Location

50 60

Neurons Importance

 

° Sp ay
© er'c0® ean oe cnene ence oom coe emooe

 

0 10

20 30 40
Neurons Location

50

60

 

Figure 8: First layer neuron importance after learning the first task (blue). Left: SNID, Right: SLNID. More
active neurons are tolerated in SLNID.

 

 

 

 

 

 

 

 

 

4.8 : z ual ta
;
vo 08 ® wv 08
g g .
oS s S
+. . e
B06 . Bos
E ° ° E °
a a ce
2 oa e e 2 oa °
§ .? ° * e s - °
3 3a : zal? oe 2 ge?
202 e 3 w ° 202 e es ge
eg e ? eee ee o®
% Siac eames asia satel he as Se
0.0 “egaeSs Seeee G2 SEAS? ELTED © REEES GSEEE STD See OES 0.0 en cn S esp te eteee epee cnet 6 eaecos @
oO 10 20 30 40 50 60 oO 10 20 30 40 50 60

Neurons Location Neurons Location

Figure 9: First layer neuron importance after learning the second task (orange), superimposed on Figure|g] Left:
SNID, Right: SLNID. SLNID allows new neurons, especially those that were close neighbours to previous
important neurons, to become active and to be used for the new task. SNID penalizes all unimportant neurons
equally. As a result, previous neurons are adapted for the new tasks and less new neurons are getting activated.

 

 

    

 

 

 

 

 

 

 

10 e ° role
°
°
gos : ao
2 2 .
S g S
B06 ° Bos :
go ° e ae°) } °
£ ° 3 E e e
a e ‘eo a ee &¢
£oa “se a £oa e °
a ee ee
a ° ° a Cry
Z 02 ° 3 o & ss 202 i *S
Ws o we on oes § =
ow ° ¢
0.01 eeemee exes %S eo essese ofilee $ Senco coneo ° eosne oxo exo | SetaSaveedear ele cies wil eneae ee
0 4610 2 30 40 50 60 ° wo 20 2«302S'ss4s=—i‘“CSC«

Neurons Location Neurons Location
Figure 10: First layer neuron importance after learning the third task (green), superimposed on Figure9] Left:
SNID, Right: SLNID. SLNID allows previous neurons to be re-used for the third task. It avoids changing the
previous important neurons by adding new neurons. For SNID, very few neurons are newly deployed. The new
task is learned mostly by adapting previous important neurons, causing more interference.

16
Published as a conference paper at ICLR 2019

 

 

 

 

 

 

 

 

 

 

iofe rofe
°
gos gos
2 g e
§ ° s
t t
Bos) | 5 06
= =
goa goa
2 ° 5
5 °, 5
z z
202 »~ 202
°,
0.0 "Ti penspneseaeaeaeesenassananaed 0.0
oO 10 20 30 40 50 60 oO 10 20 30 40 50 60
Neurons Location Neurons Location

Figure 11: First layer neuron importance after learning the first task, sorted in descending order according to the
first task neuron importance (blue). Left: SNID, Right: SLNID. More active neurons are tolerated in SLNID.

 

 

10] @ 10] ¢

og

06

06

0.4 04

Neurons Importance
Neurons Importance

02

  

0.0

 

 

 

 

 

 

0 10 20 30 40 50 60 0 10 20 30 40 50 60
Neurons Location Neurons Location

Figure 12: First layer neuron importance after learning the second task sorted in descending order according
to the first task neuron importance (orange), superimposed on top of figure[I1] Left: SNID, Right: SLNID.
SLNID allows new neurons to become active and be used for the new task. SNID penalizes all unimportant
neurons equally and hence more neurons are re-used then initiated for the first time.

 

 

 

1.0 10) @

08

06

o4

Neurons Importance
S

Neurons Importance

02

0.0 0.0

 

 

  

 

 

0 10 20 30 40 50 60 0 10 20 30 40 50 60
Neurons Location Neurons Location

 

 

Figure 13: First layer neuron importance after learning the third task sorted in descending order according to
the first task neuron importance (green), superimposed on top of figure[12] Left: SNID, Right: SLNID. SLNID
allows previous neurons to be re-used for the third task while activating new neurons to cope with the needs
of the new task. For SNID, very few neurons are newly deployed while most previous important neurons for
previous tasks are re-adapted to learn the new task.

17

